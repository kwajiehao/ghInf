}
print(results_random) # not optimal! the random labelling it is not as bad, but the ratio is still not great.
for (k in 1:20){
print(paste0("iteration", k))
temp <- centered_fillin2(method = "matrix", permute_method = "random",
i = level1[3], j = level1[3])
results[k] <- temp$diff
}
results_random[9] <- mean(results)
print(results_random) # not optimal! the random labelling it is not as bad, but the ratio is still not great.
centered_fillin2(method = "matrix", permute_method = "random",
i = level1[3], j = level1[3])
centered_fillin2(method = "matrix", permute_method = "random",
i = level1[3], j = level1[3])
centered_fillin2(method = "matrix", permute_method = "random",
i = level1[3], j = level1[3])
# plot performance against number of parameters
num_params <- rep(0, l^2)
for (i in 1:l){
for (j in 1:l){
num_params[(i-1)*l + j] <- level1[i]*level1[j] + level1[i] + 1
}
}
num_params
print(results_reverse) # not optimal! with reverse labelling the ratio is very bad.
test2_cols
print(results_reverse) # not optimal! with reverse labelling the ratio is very bad.
# calculate percentage of matrix filled in
perc_fill_reverse <- rep(0, l^2)
perc_fill_random <- perc_fill_reverse
for (i in 1:length(num_params)){
perc_fill_reverse[i] <- results_reverse[i] * (num_params[i]-1)/num_params[i]^2
perc_fill_random[i] <- results_random[i] * (num_params[i]-1)/num_params[i]^2
}
perc_fill_random
perc_fill_reverse
# plot performance against number of parameters
df_reverse <- data.frame(i = test2_rows, j = test2_cols, results = results_reverse, no_params = num_params, percentage_fill = perc_fill_reverse)
df_random <- data.frame(i = test2_rows, j = test2_cols, results = results_random, no_params = num_params, percentage_fill = perc_fill_random)
plot_reverse <- plot(df_reverse$results, df_reverse$no_params, type = 'l')
plot_random <- plot(df_random$results, df_random$no_params , type = 'l')
# plot percentage of cholesky factor filled in
plot_reverse2 <- plot(df_reverse$percentage_fill, df_reverse$no_params, type = 'l')
plot_random2 <- plot(df_random$percentage_fill, df_random$no_params , type = 'l')
# plot percentage of cholesky factor filled in
plot_reverse2 <- plot(df_reverse$percentage_fill, df_reverse$no_params, type = 'p')
plot_random2 <- plot(df_random$percentage_fill, df_random$no_params , type = 'p')
plot_random2 <- plot(df_random$percentage_fill, df_random$no_params , type = 'p')
# plot percentage of cholesky factor filled in
plot_reverse2 <- plot(df_reverse$percentage_fill, df_reverse$no_params, type = 'p')
plot_random2 <- plot(df_random$percentage_fill, df_random$no_params , type = 'p')
# plot percentage of cholesky factor filled in
plot_reverse2 <- plot(df_reverse$percentage_fill, df_reverse$no_params, type = 'p')
abline(lm(df_reverse$percentage_fill ~ df_reverse$no_params), col="red")
abline(lm(df_reverse$no_params ~ df_reverse$percentage_fill), col="red")
# plot percentage of cholesky factor filled in
plot_reverse2 <- plot(df_reverse$percentage_fill, df_reverse$no_params, type = 'p')
abline(lm(df_reverse$no_params ~ df_reverse$percentage_fill), col="red")
plot_reverse <- plot(df_reverse$no_params, df_reverse$results, type = 'l')
plot_reverse <- plot(df_reverse$no_params, df_reverse$results, type = 'l')
plot_random <- plot(df_random$no_params, df_random$results, type = 'l')
don't forget to export images'
# plot percentage of cholesky factor filled in
plot_reverse2 <- plot(df_reverse$no_params, df_reverse$percentage_fill, type = 'p')
abline(lm(df_reverse$percentage_fill ~ df_reverse$no_params), col="red")
plot_random2 <- plot(df_random$no_params, df_random$percentage_fill, type = 'p')
abline(lm(df_random$percentage_fill ~ df_random$no_params), col="red")
# plot percentage of cholesky factor filled in
plot_reverse2 <- plot(df_reverse$no_params, df_reverse$percentage_fill, type = 'p')
# plot percentage of cholesky factor filled in
plot_reverse2 <- plot(df_reverse$no_params, df_reverse$percentage_fill, type = 'p')
loess.smooth(df_reverse$no_params, df_reverse$percentage_fill)
scatter.smooth(df_reverse$no_params, df_reverse$percentage_fill)
scatter.smooth(df_reverse$no_params, df_reverse$percentage_fill, span = 0.5)
# plot percentage of cholesky factor filled in
plot_reverse2 <- plot(df_reverse$no_params, df_reverse$percentage_fill, type = 'p')
scatter.smooth(df_reverse$no_params, df_reverse$percentage_fill, span = 0.5)
scatter.smooth(df_reverse$no_params, df_reverse$percentage_fill, span = 0.8)
scatter.smooth(df_reverse$no_params, df_reverse$percentage_fill, span = 0.9)
plot_reverse <- plot(df_reverse$no_params, df_reverse$results, type = 'l')
plot_random <- plot(df_random$no_params, df_random$results, type = 'l')
# plot percentage of cholesky factor filled in
plot(df_reverse$no_params, df_reverse$percentage_fill, type = 'p')
scatter.smooth(df_reverse$no_params, df_reverse$percentage_fill, span = 0.9, main = "")
scatter.smooth(df_reverse$no_params, df_reverse$percentage_fill, span = 0.9,
main = "percentage fill of cholesky factor against number of parameters",
xlab = "no. of params", ylab = "percentage fill", ylim = c(0, 1))
scatter.smooth(df_reverse$no_params, df_reverse$percentage_fill, span = 0.9,
main = "percentage fill of cholesky factor against number of parameters",
xlab = "no. of params", ylab = "percentage fill", ylim = c(0, 0.5))
scatter.smooth(df_reverse$no_params, df_reverse$percentage_fill, span = 0.9,
main = "percentage fill of cholesky factor against number of parameters",
xlab = "no. of params", ylab = "percentage fill", ylim = c(0, 0.25))
scatter.smooth(df_reverse$no_params, df_reverse$percentage_fill, span = 0.9,
main = "percentage fill of cholesky factor against number of parameters",
xlab = "no. of params", ylab = "percentage fill", ylim = c(0, 0.5))
scatter.smooth(df_reverse$no_params, df_reverse$percentage_fill, span = 0.9,
main = "percentage fill of cholesky factor against number of parameters",
xlab = "no. of params", ylab = "percentage fill", ylim = c(0.25, 0.5))
scatter.smooth(df_reverse$no_params, df_reverse$percentage_fill, span = 0.9,
main = "percentage fill of cholesky factor against number of parameters",
xlab = "no. of params", ylab = "percentage fill", ylim = c(0, 0.5))
abline(lm(df_reverse$percentage_fill ~ df_reverse$no_params), col="red")
plot_random2 <- plot(df_random$no_params, df_random$percentage_fill, type = 'p')
abline(lm(df_random$percentage_fill ~ df_random$no_params), col="red")
plot_random2 <- plot(df_random$no_params, df_random$percentage_fill, type = 'p')
scatter.smooth(df_random$no_params, df_random$percentage_fill, span = 0.9,
main = "percentage fill of cholesky factor against number of parameters (random permutation)",
xlab = "no. of params", ylab = "percentage fill", ylim = c(0, 0.5))
plot(df_random$no_params, df_random$percentage_fill, type = 'p')
scatter.smooth(df_random$no_params, df_random$percentage_fill, span = 0.9,
main = "percentage fill of cholesky factor against number of parameters (random permutation)",
xlab = "no. of params", ylab = "percentage fill", ylim = c(0, 0.5))
plot(df_random$no_params, df_random$percentage_fill, type = 'p')
scatter.smooth(df_random$no_params, df_random$percentage_fill, span = 0.9,
main = "percentage fill of cholesky factor against number of parameters (random permutation)",
xlab = "no. of params", ylab = "percentage fill", ylim = c(0, 0.5))
plot(df_random$no_params, df_random$percentage_fill, type = 'p')
abline(lm(df_random$percentage_fill ~ df_random$no_params), col="red")
scatter.smooth(df_random$no_params, df_random$percentage_fill, span = 0.9,
main = "percentage fill of cholesky factor against number of parameters (random permutation)",
xlab = "no. of params", ylab = "percentage fill", ylim = c(0, 0.5))
# plot percentage of cholesky factor filled in
plot(df_reverse$no_params, df_reverse$percentage_fill, type = 'p')
scatter.smooth(df_random$no_params, df_random$percentage_fill, span = 0.9,
main = "percentage fill of cholesky factor against number of parameters (random permutation)",
xlab = "no. of params", ylab = "percentage fill", ylim = c(0, 0.5))
# plot performance against number of parameters
df_reverse <- data.frame(i = test2_rows, j = test2_cols, results = results_reverse, no_params = num_params, percentage_fill = perc_fill_reverse)
df_random <- data.frame(i = test2_rows, j = test2_cols, results = results_random, no_params = num_params, percentage_fill = perc_fill_random)
plot_reverse <- plot(df_reverse$no_params, df_reverse$results, type = 'l')
plot_reverse <- plot(df_reverse$no_params, df_reverse$results, type = 'l',
main = 'ratio of fill-in to optimal fill-in', xlab = 'no. of params', ylab = 'ratio')
plot_random <- plot(df_random$no_params, df_random$results, type = 'l',
main = 'ratio of fill-in to optimal fill-in', xlab = 'no. of params', ylab = 'ratio')
plot(df_reverse$no_params, df_reverse$results, type = 'l',
main = 'ratio of fill-in to optimal fill-in', xlab = 'no. of params', ylab = 'ratio')
plot(df_random$no_params, df_random$results, type = 'l',
main = 'ratio of fill-in to optimal fill-in', xlab = 'no. of params', ylab = 'ratio')
plot(df_reverse$no_params, df_reverse$results, type = 'l',
main = 'ratio of fill-in to optimal fill-in', xlab = 'no. of params', ylab = 'ratio')
plot(df_reverse$no_params, df_reverse$results, type = 'l',
main = 'ratio of fill-in to optimal fill-in', xlab = 'no. of params', ylab = 'ratio')
plot(df_reverse$no_params, df_reverse$results, type = 'l',
main = 'ratio of fill-in to optimal fill-in (reverse permutation)', xlab = 'no. of params', ylab = 'ratio')
plot(df_random$no_params, df_random$results, type = 'l',
main = 'ratio of fill-in to optimal fill-in (random permutation)', xlab = 'no. of params', ylab = 'ratio')
don't forget to export images'
# plot with both
plot(df_reverse$no_params, df_reverse$results, type = 'l',
main = 'ratio of fill-in to optimal fill-in (reverse permutation)', xlab = 'no. of params', ylab = 'ratio')
# plot with both
plot(df_reverse$no_params, df_reverse$results, type = 'l',
main = 'ratio of fill-in to optimal fill-in', xlab = 'no. of params', ylab = 'ratio')
points(df_random$no_params, df_random$results, col = 'red')
lines(df_random$no_params, df_random$results, col = 'red')
legend(legend=c("reverse","random"), col=c("black","red")
legend(legend=c("reverse","random"), col=c("black","red"))
legend(legend=c("reverse","random"), col=c("black","red"))
legend(0, 5000, legend=c("reverse","random"), col=c("black","red"))
# plot with both
plot(df_reverse$no_params, df_reverse$results, type = 'l',
main = 'ratio of fill-in to optimal fill-in', xlab = 'no. of params', ylab = 'ratio')
points(df_reverse$no_params, df_reverse$results, col = 'black', pch = "o")
points(df_random$no_params, df_random$results, col = 'red', pch = "*")
lines(df_random$no_params, df_random$results, col = 'red')
legend(0, 5000, legend=c("reverse","random"), col=c("black","red"), pch=c("o","*"))
plot(df_reverse$no_params, df_reverse$percentage_fill, type = 'p')
abline(lm(df_reverse$percentage_fill ~ df_reverse$no_params), col="red")
plot(df_reverse$no_params^2, df_reverse$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero of cholesky factor (reverse permutation)',
xlab = 'no. of params', ylab = 'percentage filled')
plot((df_reverse$no_params)^2, df_reverse$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero of cholesky factor (reverse permutation)',
xlab = 'no. of params', ylab = 'percentage filled')
abline(lm(df_reverse$percentage_fill ~ (df_reverse$no_params)^2), col="red")
plot(df_reverse$no_params, df_reverse$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero of cholesky factor (reverse permutation)',
xlab = 'no. of params', ylab = 'percentage filled')
abline(lm(df_reverse$percentage_fill ~ df_reverse$no_params), col="red")
plot(df_reverse$no_params, df_reverse$results, type = 'l',
main = 'ratio of fill-in to optimal fill-in (reverse permutation)', xlab = 'no. of params', ylab = 'ratio')
plot(df_random$no_params, df_random$results, type = 'l',
main = 'ratio of fill-in to optimal fill-in (random permutation)', xlab = 'no. of params', ylab = 'ratio')
# plot with both
plot(df_reverse$no_params, df_reverse$results, type = 'l',
main = 'ratio of fill-in to optimal fill-in', xlab = 'no. of params', ylab = 'ratio')
points(df_reverse$no_params, df_reverse$results, col = 'black', pch = "o")
points(df_random$no_params, df_random$results, col = 'red', pch = "*")
lines(df_random$no_params, df_random$results, col = 'red')
legend(0, 5000, legend=c("reverse","random"), col=c("black","red"), pch=c("o","*"))
plot(df_reverse$no_params, df_reverse$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero of cholesky factor (reverse permutation)',
xlab = 'no. of params', ylab = 'percentage filled')
abline(lm(df_reverse$percentage_fill ~ df_reverse$no_params), col="red")
plot(df_random$no_params, df_random$percentage_fill, type = 'p')
abline(lm(df_random$percentage_fill ~ df_random$no_params), col="red")
plot(df_random$no_params, df_random$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero of cholesky factor (random permutation)',
xlab = 'no. of params', ylab = 'percentage filled')
abline(lm(df_random$percentage_fill ~ df_random$no_params), col="red")
plot(df_reverse$no_params, df_reverse$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero of cholesky factor',
xlab = 'no. of params', ylab = 'percentage filled')
abline(lm(df_reverse$percentage_fill ~ df_reverse$no_params), col="black")
points(df_random$no_params, df_random$percentage_fill, pch = '*', col = "red")
abline(lm(df_random$percentage_fill ~ df_random$no_params), col = "red")
plot(df_reverse$no_params, df_reverse$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero of cholesky factor',
xlab = 'no. of params', ylab = 'percentage filled')
abline(lm(df_reverse$percentage_fill ~ df_reverse$no_params), col="black")
points(df_random$no_params, df_random$percentage_fill, pch = '*', col = "red")
abline(lm(df_random$percentage_fill ~ df_random$no_params), col = "red")
plot(df_reverse$no_params, df_reverse$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero of cholesky factor',
xlab = 'no. of params', ylab = 'percentage filled', ylim = c(0, 0.5))
abline(lm(df_reverse$percentage_fill ~ df_reverse$no_params), col="black")
points(df_random$no_params, df_random$percentage_fill, pch = '*', col = "red")
abline(lm(df_random$percentage_fill ~ df_random$no_params), col = "red")
plot(df_reverse$no_params, df_reverse$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero (reverse permutation)',
xlab = 'no. of params', ylab = 'percentage filled')
abline(lm(df_reverse$percentage_fill ~ df_reverse$no_params), col="red")
plot(df_random$no_params, df_random$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero of cholesky factor (random permutation)',
xlab = 'no. of params', ylab = 'percentage filled')
abline(lm(df_random$percentage_fill ~ df_random$no_params), col="red")
tage_fill, type = 'p', main = 'percentage of entries that are non-zero (random permutation)',
xlab = 'no. of params', ylab = 'perce
plot(df_random$no_params, df_random$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero (random permutation)',
xlab = 'no. of params', ylab = 'percentage filled')
abline(lm(df_random$percentage_fill ~ df_random$no_params), col="red")
plot(df_reverse$no_params, df_reverse$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero of cholesky factor',
xlab = 'no. of params', ylab = 'percentage filled', ylim = c(0, 0.5))
abline(lm(df_reverse$percentage_fill ~ df_reverse$no_params), col="black")
points(df_random$no_params, df_random$percentage_fill, pch = '*', col = "red")
abline(lm(df_random$percentage_fill ~ df_random$no_params), col = "red")
abline(lm(df_reverse$percentage_fill ~ (df_reverse$no_params^2)), col="red")
plot(df_reverse$no_params, df_reverse$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero (reverse permutation)',
xlab = 'no. of params', ylab = 'percentage filled')
abline(lm(df_reverse$percentage_fill ~ (df_reverse$no_params^2)), col="red")
plot((df_reverse$no_params^2), df_reverse$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero (reverse permutation)',
xlab = 'no. of params', ylab = 'percentage filled')
abline(lm(df_reverse$percentage_fill ~ (df_reverse$no_params^2)), col="red")
plot((df_reverse$no_params, df_reverse$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero (reverse permutation)',
plot(df_reverse$no_params, df_reverse$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero (reverse permutation)',
xlab = 'no. of params', ylab = 'percentage filled')
abline(lm(df_reverse$percentage_fill ~ (df_reverse$no_params^2)), col="red")
plot(df_random$no_params, df_random$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero (random permutation)',
xlab = 'no. of params', ylab = 'percentage filled')
abline(lm(df_random$percentage_fill ~ (df_random$no_params^2)), col="red")
plot(df_reverse$no_params, df_reverse$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero (reverse permutation)',
xlab = 'no. of params', ylab = 'percentage filled')
abline(lm(df_reverse$percentage_fill ~ (df_reverse$no_params^2)), col="red")
plot(df_random$no_params, df_random$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero (random permutation)',
xlab = 'no. of params', ylab = 'percentage filled')
abline(lm(df_random$percentage_fill ~ (df_random$no_params^2)), col="red")
plot(df_reverse$no_params, df_reverse$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero of cholesky factor',
xlab = 'no. of params', ylab = 'percentage filled', ylim = c(0, 0.5))
abline(lm(df_reverse$percentage_fill ~ (df_reverse$no_params^2)), col="black")
points(df_random$no_params, df_random$percentage_fill, pch = '*', col = "red")
abline(lm(df_random$percentage_fill ~ (df_random$no_params^2)), col = "red")
legend(0, 0.5, legend=c("reverse","random"), col=c("black","red"), pch=c("o","*"))
legend(0, 0.3, legend=c("reverse","random"), col=c("black","red"), pch=c("o","*"),)
plot(df_reverse$no_params, df_reverse$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero of cholesky factor',
xlab = 'no. of params', ylab = 'percentage filled', ylim = c(0, 0.5))
abline(lm(df_reverse$percentage_fill ~ (df_reverse$no_params^2)), col="black")
points(df_random$no_params, df_random$percentage_fill, pch = '*', col = "red")
abline(lm(df_random$percentage_fill ~ (df_random$no_params^2)), col = "red")
legend(0, 0.3, legend=c("reverse","random"), col=c("black","red"), pch=c("o","*"))
# load library
library(MASS)
# sample specifications
burn <- 100
size <- 10000
# generate samples from the 2-level gibbs sampler
i <- 10
j <- 20
results_gibbs <- centered_gibbs2(i = i, j = j, ndraws = size, burnin = burn, flat_prior = TRUE,
tau = 1, tau_a = 2, tau_b = 1, sigma_2 = 2)
samples_gibbs <- results_gibbs$samples[,(burn+1):(size+burn)]
# trace plot for 2-level gibbs samples
df <- data.frame(iterations = seq(1, size), B = samples_gibbs[nrow(samples_gibbs),])
trace2 <- plot(df$iterations, df$B, type = 'l', main = 'Trace plot of beta',
xlab = 'iterations', ylab = 'beta')
# generate samples with the precision matrix
results_exact <- centered_precgen2(i = i, j = j, flat_prior = TRUE, tau = 1, tau_a = 2, tau_b = 1, sigma_2 = 2)
Q_exact <- sparseMatrix(results_exact$indices_i, results_exact$indices_j, x = results_exact$entries)
cov_exact <- solve(Q_exact)
samples_exact <- mvrnorm(n = size, mu = rep(0, dim(cov_exact)[1]), Sigma = cov_exact)
samples_exact <- t(samples_exact)
# qqplot of samples from gibbs vs exact sampling
df2 <- data.frame(gauss_B = sort(samples_exact[nrow(samples_exact),]),
B = sort(samples_gibbs[nrow(samples_gibbs),]))
qq2 <- plot(df2$gauss_B, df2$B, main = "QQ plot of beta samples from Gibbs vs
Gaussian Simulation", xlab = "Gaussian Simulation", ylab = "Gibbs")
abline(a = 0, b = 1, col = 'red')
# load library
library(MASS)
# sample specifications
burn <- 100
size <- 10000
# generate samples from the 3-level gibbs sampler
i <- 10
# generate samples from the 3-level gibbs sampler
i <- 10
j <- 11
k <- 12
results_gibbs <- centered_gibbs3(i = i, j = j, k = k, ndraws = size, burnin = burn, flat_prior = TRUE,
tau = 1, tau_a = 2, tau_b = 1, tau_c = 2, sigma_2 = 2)
samples_gibbs <- results_gibbs$samples[,(burn+1):(size+burn)]
# trace plot for 3-level gibbs samples
df <- data.frame(iterations = seq(1, size), B = samples_gibbs[nrow(samples_gibbs),])
trace3 <- plot(df$iterations, df$B, type = 'l', main = 'Trace plot of beta',
xlab = 'iterations', ylab = 'beta')
# generate samples with the precision matrix
results_exact <- centered_precgen3(i = i, j = j, k = k, flat_prior = TRUE, tau = 1, tau_a = 2, tau_b = 1,
tau_c = 2, sigma_2 = 2)
Q_exact <- sparseMatrix(results_exact$indices_i, results_exact$indices_j, x = results_exact$entries)
cov_exact <- solve(Q_exact)
samples_exact <- mvrnorm(n = size, mu = rep(0, dim(cov_exact)[1]), Sigma = cov_exact)
samples_exact <- t(samples_exact)
# qqplot of samples from gibbs vs exact sampling
df2 <- data.frame(gauss_B = sort(samples_exact[nrow(samples_exact),]),
B = sort(samples_gibbs[nrow(samples_gibbs),]))
qq2 <- plot(df2$gauss_B, df2$B, main = "QQ plot of beta samples from Gibbs vs
Gaussian Simulation", xlab = "Gaussian Simulation", ylab = "Gibbs")
abline(a = 0, b = 1, col = 'red')
# increasing order
i = 1000
J = seq(1, i)
results_inc <- zero_counter2(method="both", i=i, J=J)
results_inc <- fillin(method="spam", i=i, J=J)
results_inc
results_inc <- fillin2(method="spam", i=i, J=J)
# increasing order
i = 10
J = seq(1, i)
results_inc <- fillin2(method="spam", i=i, J=J)
results_inc
# increasing order
i = 100
J = seq(1, i)
results_inc <- fillin2(method="spam", i=i, J=J)
results_inc$ diff
# pyramid
i = 5
# pyramid
i = 100
J = c(seq(1, floor(i/2)), seq(floor(i/2),1))
if (i%%2 == 1){J = c(seq(1, floor(i/2)), floor(i/2)+1, seq(floor(i/2),1))}
results_pyr <- zero_counter2(method="spam", i=i, J=J)
results_pyr <- fillin2(method="spam", i=i, J=J)
results_pyr$diff
# extremes
i = 100
J = rep(1,i)
J[1] <- i
J[i] <- i
results_ext <- fillin2(method="spam", i=i, J=J)
results_ext
results_ext$diff
# import libraries
library(Matrix)
library(spam)
library(spam64)
# increasing order
i = 100
J = seq(1, i)
results_inc <- fillin2(method="matrix", i=i, J=J)
results_inc$ diff
# pyramid
i = 100
J = c(seq(1, floor(i/2)), seq(floor(i/2),1))
if (i%%2 == 1){J = c(seq(1, floor(i/2)), floor(i/2)+1, seq(floor(i/2),1))}
results_pyr <- fillin2(method="matrix", i=i, J=J)
results_pyr$diff
# extremes
i = 100
J = rep(1,i)
J[1] <- i
J[i] <- i
results_ext <- fillin2(method="matrix", i=i, J=J)
results_ext$diff
I <- 2
J <- 4
# without permutation, I use a lexicographic ordering
n <- I*J + I + 1
test_mat <- centered_precgen2(i = I, j = J)
test <- centered_precgen2(i = I, j = J)
test_mat <- sparseMatrix(test$indices_i, test$indices_j, x = test$entries)
test_mat
test_mat <- as.Matrix(test_mat)
test_mat <- as.matrix(test_mat)
cols <- rep('a', n)
rows <- cols
cols <- rep('a', n)
for (i in 1:I){
for (j in 1:J){
cols[(i-1)*J + j] <- paste0('B', i, j)
}
cols[(I*J) + i] <- paste0('B', i)
}
cols
cols <- rep('B', n)
for (i in 1:I){
for (j in 1:J){
cols[(i-1)*J + j] <- paste0('B', i, j)
}
cols[(I*J) + i] <- paste0('B', i)
}
rows <- cols
colnames(test_mat) <- cols
rownames(test_mat) <- rows
print(test_mat)
# depth-first ordering
og <- depthfirst(i = I, j = J, levels = 2)
print(test_mat[og, og])
# reverse ordering
o <- seq(1, n)
og <- sample(o)
print(test_mat[og, og])
# reverse ordering
o <- seq(1, n)
og <- rev(o)
print(test_mat[og, og])
#' @param permute determines whether or not to use default row permutation algorithm before matrix factorization to reduce fill-in
#' @param ... for other params used in centered_precgen2
#'
#' @return the fill-in ratio with respect to the optimal fill-in, and the time taken for the cholesky decomposition
#' @export
#'
#' @examples
#' i <- 2
#' j <- 3
#' centered_fillin2(method = 'matrix', permute_method = 'random', i = i, j = j)
centered_fillin2 <- function(method = 'both', permute_method = 'none', i, j, permute = TRUE,...){
# sparse precision generation
q <- centered_precgen2(i, j, ...)
# permutation of sequence of row/columns according to user's choice of permute method
o <- seq(1, (i*j + i + 1))
if (permute_method=="none"){
og <- o
}
if (permute_method=="random"){
og <- sample(o)
}
if (permute_method=="depthfirst"){
og <- depthfirst(i,j, levels = 2)
}
if (permute_method == "reverse"){
og <- rev(o)
}
# number of variables ignoring the root variable
d_minus_one <- i*j + i
if (method == "spam"){
# print(c(i,j))
Q_spam <- spam::spam(0, (i*j+i+1), (i*j+i+1))
Q_spam[cbind(q$indices_i, q$indices_j)] <- q$entries
Q_spam <- Q_spam[og,og]
# start time
start <- Sys.time()
# cholesky factor
cholesky <- spam::chol(Q_spam, pivot = permute)
# end time
end <- Sys.time() - start
# count zeros
nonzero_count <- utils::tail(cholesky@rowpointers, 1) - 1 - cholesky@dimension[1]
# return list of ratios and time taken
return(list(diff = (nonzero_count / d_minus_one), time_taken = end, cky = cholesky, q=q))
}
if (method == "matrix"){
# print(c(i,j))
Q <- Matrix::sparseMatrix(q$indices_i, q$indices_j, x = q$entries)
Q <- Q[og,og]
# start time
start <- Sys.time()
# cholesky factor
cholesky <- Matrix::chol(Q, pivot = permute)
# end time
end <- Sys.time() - start
# count zeros
nonzero_count <- utils::tail(cholesky@p,1) - cholesky@Dim[1]
# return list of ratios and time taken
return(list(diff = (nonzero_count / d_minus_one), time_taken = end, cky = cholesky))
}
if (method == "both"){
# print(c(i,j))
## matrix method
Q <- Matrix::sparseMatrix(q$indices_i, q$indices_j, x = q$entries)
Q <- Q[og,og]
# start time
start <- Sys.time()
# cholesky factor
cholesky <- Matrix::chol(Q, pivot = permute)
# end time
end <- Sys.time() - start
# count zeros
nonzero_count <- utils::tail(cholesky@p,1) - cholesky@Dim[1]
## spam method
Q_spam <- spam::spam(0, (i*j+i+1), (i*j+i+1))
Q_spam[cbind(q$indices_i, q$indices_j)] <- q$entries
Q_spam <- Q_spam[og,og]
# start time
start <- Sys.time()
# cholesky factor
cholesky_spam <- spam::chol(Q_spam, pivot = permute)
# end time
end2 <- Sys.time() - start
# count zeros
nonzero_count2 <- utils::tail(cholesky_spam@rowpointers, 1) - 1 - cholesky_spam@dimension[1]
# return list of ratios and time taken
return(list(diff_matrix = (nonzero_count / d_minus_one), diff_spam = (nonzero_count2 / d_minus_one),
time_taken_matrix = end, time_taken_spam = end2))
}
}
centered_fillin2(i=2,j=3,permute_method = "reverse")
devtools::load_all(".")
devtools::load_all(".")
centered_fillin2(i=2,j=3,permute_method = "reverse")
centered_fillin2(i=2,j=3,permute_method = "reverse", method = "matrix")
centered_fillin2(i=2,j=3,permute_method = "reverse", method = "matrix", permute = FALSE)
