}
}
print(results) # optimal fill-in
devtools::load_all(".")
# import libraries
library(Matrix)
library(spam)
library(spam64)
library(ggplot2)
# number of children at each level
level1 <- c(10, 50, 100)
l <- length(level1)
# results with pivot = TRUE
results <- rep(0, l^2)
for (i in 1:l){
for (j in 1:l){
temp <- centered_fillin2(method = "spam", permute_method = "none",
i = level1[i], j = level1[j])
results[(i-1)*l + j] <- temp$diff
}
}
print(results) # optimal fill-in
# with depth-first labelling
results <- rep(0, l^2)
for (i in 1:l){
for (j in 1:l){
temp <- centered_fillin2(method = "spam", permute_method = "depthfirst",
i = level1[i], j = level1[j])
results[(i-1)*l + j] <- temp$diff
}
}
print(results) # optimal fill-in
# with reverse labelling
results <- rep(0, l^2)
for (i in 1:l){
for (j in 1:l){
temp <- centered_fillin2(method = "spam", permute_method = "reverse",
i = level1[i], j = level1[j])
results[(i-1)*l + j] <- temp$diff
}
}
print(results) # optimal fill-in
# with random labelling
results <- rep(0, l^2)
for (i in 1:l){
for (j in 1:l){
temp <- centered_fillin2(method = "spam", permute_method = "random",
i = level1[i], j = level1[j])
results[(i-1)*l + j] <- temp$diff
}
}
print(results) # optimal fill-in
# results with pivot = FALSE
results <- rep(0, l^2)
for (i in 1:l){
for (j in 1:l){
temp <- centered_fillin2(method = "spam", permute_method = "none",
i = level1[i], j = level1[j])
results[(i-1)*l + j] <- temp$diff
}
}
print(results) # optimal fill-in
# with depth-first labelling
results <- rep(0, l^2)
for (i in 1:l){
for (j in 1:l){
temp <- centered_fillin2(method = "spam", permute_method = "depthfirst",
i = level1[i], j = level1[j], permute = FALSE)
results[(i-1)*l + j] <- temp$diff
}
}
print(results) # optimal fill-in
# with reverse labelling
results <- rep(0, l^2)
for (i in 1:l){
for (j in 1:l){
temp <- centered_fillin2(method = "spam", permute_method = "reverse",
i = level1[i], j = level1[j], permute = FALSE)
results[(i-1)*l + j] <- temp$diff
}
}
warnings()
print(results) #
# with random labelling
results <- rep(0, l^2)
for (i in 1:l){
for (j in 1:l){
temp <- centered_fillin2(method = "spam", permute_method = "random",
i = level1[i], j = level1[j], permute = FALSE)
results[(i-1)*l + j] <- temp$diff
}
}
print(results) #
# results with pivot = TRUE
results <- rep(0, l^2)
for (i in 1:l){
for (j in 1:l){
temp <- centered_fillin2(method = "matrix", permute_method = "none",
i = level1[i], j = level1[j], permute = TRUE)
results[(i-1)*l + j] <- temp$diff
}
}
print(results) # optimal fill-in
# with depth-first labelling
results <- rep(0, l^2)
# with depth-first labelling
results <- rep(0, l^2)
for (i in 1:l){
for (j in 1:l){
temp <- centered_fillin2(method = "matrix", permute_method = "depthfirst",
i = level1[i], j = level1[j], permute = TRUE)
results[(i-1)*l + j] <- temp$diff
}
}
print(results) # optimal fill-in
# with reverse labelling (this takes some time)
results_reverse <- rep(0, l^2)
for (i in 1:l){
for (j in 1:l){
temp <- centered_fillin2(method = "matrix", permute_method = "reverse",
i = level1[i], j = level1[j], permute = TRUE)
results_reverse[(i-1)*l + j] <- temp$diff
}
}
print(results_reverse) #
# with random labelling
results_random <- rep(0, l^2)
for (i in 1:l){
for (j in 1:l){
temp <- centered_fillin2(method = "matrix", permute_method = "random",
i = level1[i], j = level1[j], permute = TRUE)
results_random[(i-1)*l + j] <- temp$diff
}
}
print(results_random) #
# results with pivot = FALSE
results <- rep(0, l^2)
for (i in 1:l){
for (j in 1:l){
temp <- centered_fillin2(method = "matrix", permute_method = "none",
i = level1[i], j = level1[j])
results[(i-1)*l + j] <- temp$diff
}
}
# with depth-first labelling
results <- rep(0, l^2)
for (i in 1:l){
for (j in 1:l){
temp <- centered_fillin2(method = "matrix", permute_method = "depthfirst",
i = level1[i], j = level1[j])
results[(i-1)*l + j] <- temp$diff
}
}
# with reverse labelling (this takes some time)
results_reverse <- rep(0, l^2)
print(results) # optimal fill-in
# with depth-first labelling
results <- rep(0, l^2)
for (i in 1:l){
for (j in 1:l){
temp <- centered_fillin2(method = "matrix", permute_method = "depthfirst",
i = level1[i], j = level1[j])
results[(i-1)*l + j] <- temp$diff
}
}
print(results) # optimal fill-in
# with reverse labelling (this takes some time)
results_reverse <- rep(0, l^2)
for (i in 1:l){
for (j in 1:l){
temp <- centered_fillin2(method = "matrix", permute_method = "reverse",
i = level1[i], j = level1[j])
results_reverse[(i-1)*l + j] <- temp$diff
}
}
print(results_reverse) # not optimal! with reverse labelling the ratio is very bad.
# with reverse labelling (this takes some time)
results_reverse <- rep(0, l^2)
for (i in 1:l){
for (j in 1:l){
temp <- centered_fillin2(method = "matrix", permute_method = "reverse",
i = level1[i], j = level1[j])
results_reverse[(i-1)*l + j] <- temp$diff
}
}
print(results_reverse) # not optimal! with reverse labelling the ratio is very bad.
# with random labelling
results_random <- rep(0, l^2)
for (i in 1:l){
for (j in 1:l){
temp <- centered_fillin2(method = "matrix", permute_method = "random",
i = level1[i], j = level1[j])
results_random[(i-1)*l + j] <- temp$diff
}
}
print(results_random) # not optimal! the random labelling it is not as bad, but the ratio is still not great.
# with depth-first labelling
results <- rep(0, l^2)
for (i in 1:l){
for (j in 1:l){
temp <- centered_fillin2(method = "matrix", permute_method = "depthfirst",
i = level1[i], j = level1[j], permute = FALSE)
results[(i-1)*l + j] <- temp$diff
}
}
# with reverse labelling (this takes some time)
results_reverse <- rep(0, l^2)
for (i in 1:l){
for (j in 1:l){
temp <- centered_fillin2(method = "matrix", permute_method = "reverse",
i = level1[i], j = level1[j])
results_reverse[(i-1)*l + j] <- temp$diff
}
}
# with reverse labelling (this takes some time)
results_reverse <- rep(0, l^2)
for (i in 1:l){
for (j in 1:l){
temp <- centered_fillin2(method = "matrix", permute_method = "reverse",
i = level1[i], j = level1[j], permute = FALSE)
results_reverse[(i-1)*l + j] <- temp$diff
}
}
print(results_reverse) # not optimal! with reverse labelling the ratio is very bad.
# with random labelling
results_random <- rep(0, l^2)
for (i in 1:l){
for (j in 1:l){
temp <- centered_fillin2(method = "matrix", permute_method = "random",
i = level1[i], j = level1[j], permute = FALSE)
results_random[(i-1)*l + j] <- temp$diff
}
}
print(results_random) # not optimal! the random labelling it is not as bad, but the ratio is still not great.
# increasing order
i = 100
J = seq(1, i)
results_inc <- fillin2(method="spam", i=i, J=J)
results_inc$ diff
# pyramid
i = 100
# import libraries
library(Matrix)
library(spam)
library(spam64)
# increasing order
i = 100
J = seq(1, i)
results_inc <- fillin2(method="spam", i=i, J=J)
results_inc$ diff
devtools::load_all(".")
# import libraries
library(Matrix)
library(spam)
library(spam64)
# increasing order
i = 100
J = seq(1, i)
results_inc <- fillin2(method="spam", i=i, J=J)
results_inc$ diff
# pyramid
i = 100
J = c(seq(1, floor(i/2)), seq(floor(i/2),1))
if (i%%2 == 1){J = c(seq(1, floor(i/2)), floor(i/2)+1, seq(floor(i/2),1))}
results_pyr <- fillin2(method="spam", i=i, J=J)
results_pyr$diff
# extremes
i = 100
J = rep(1,i)
J[1] <- i
J[i] <- i
results_ext <- fillin2(method="spam", i=i, J=J)
results_ext$diff
# all three tests show that optimal fill-in is returned
# all three tests show that optimal fill-in is returned
# import libraries
library(Matrix)
library(spam)
library(spam64)
# increasing order
i = 100
J = seq(1, i)
results_inc <- fillin2(method="matrix", i=i, J=J)
results_inc$ diff
# pyramid
i = 100
J = c(seq(1, floor(i/2)), seq(floor(i/2),1))
if (i%%2 == 1){J = c(seq(1, floor(i/2)), floor(i/2)+1, seq(floor(i/2),1))}
results_pyr <- fillin2(method="matrix", i=i, J=J)
results_pyr$diff
# extremes
i = 100
J = rep(1,i)
J[1] <- i
J[i] <- i
results_ext <- fillin2(method="matrix", i=i, J=J)
results_ext$diff
# all three tests show that optimal fill-in is returned
# all three tests show that optimal fill-in is returned
# all three tests show that optimal fill-in is returned
# all three tests show that optimal fill-in is returned
# all three tests show that optimal fill-in is returned
# import libraries
library(Matrix)
library(spam)
library(spam64)
library(ggplot2)
# number of children at each level
level1 <- c(10, 50, 100)
l <- length(level1)
# store values of i and j, and the number of parameters
test2_cols <- rep(level1, l)
test2_rows <- c()
for (i in 1:l){
test2_rows <- c(test2_rows, rep(level1[i], l))
}
num_params <- rep(0, l^2)
for (i in 1:l){
for (j in 1:l){
num_params[(i-1)*l + j] <- level1[i]*level1[j] + level1[i] + 1
}
}
# with reverse labelling (this takes some time)
results_reverse <- rep(0, l^2)
for (i in 1:l){
for (j in 1:l){
temp <- centered_fillin2(method = "spam", permute_method = "reverse",
i = level1[i], j = level1[j], permute = FALSE)
results_reverse[(i-1)*l + j] <- temp$diff
}
}
# with random labelling
reps <- 10 # reduce this number since this might take a while
results <- rep(0, reps) # take the average to account for random effects
results_random <- rep(0, l^2)
for (i in 1:l){
for (j in 1:l){
print(paste0("level 1: ", level1[i], ", level 2: ", level1[j]))
for (k in 1:reps){
print(paste0("iteration", k))
temp <- centered_fillin2(method = "spam", permute_method = "random",
i = level1[i], j = level1[j], permute = FALSE)
results[k] <- temp$diff
}
results_random[(i-1)*l + j] <- mean(results)
}
}
print(results_random) # not optimal! the random labelling it is not as bad, but the ratio is still not great.
# calculate percentage of matrix filled in
perc_fill_reverse <- rep(0, l^2)
perc_fill_random <- perc_fill_reverse
for (i in 1:length(num_params)){
perc_fill_reverse[i] <- results_reverse[i] * (num_params[i]-1)/num_params[i]^2
perc_fill_random[i] <- results_random[i] * (num_params[i]-1)/num_params[i]^2
}
# plot performance against number of parameters
df_reverse <- data.frame(i = test2_rows, j = test2_cols, results = results_reverse, no_params = num_params, percentage_fill = perc_fill_reverse)
df_random <- data.frame(i = test2_rows, j = test2_cols, results = results_random, no_params = num_params, percentage_fill = perc_fill_random)
plot(df_reverse$no_params, df_reverse$results, type = 'l',
main = 'ratio of fill-in to optimal fill-in (reverse permutation)', xlab = 'no. of params', ylab = 'ratio')
plot(df_random$no_params, df_random$results, type = 'l',
main = 'ratio of fill-in to optimal fill-in (random permutation)', xlab = 'no. of params', ylab = 'ratio')
df_random <- data.frame(i = test2_rows, j = test2_cols, results = results_random, no_params = num_params, percentage_fill = perc_fill_random)
plot(df_reverse$no_params, df_reverse$results, type = 'l',
main = 'ratio of fill-in to optimal fill-in (reverse permutation)', xlab = 'no. of params', ylab = 'ratio')
plot(df_random$no_params, df_random$results, type = 'l',
main = 'ratio of fill-in to optimal fill-in (random permutation)', xlab = 'no. of params', ylab = 'ratio')
plot(df_random$no_params, df_random$results, type = 'p',
main = 'ratio of fill-in to optimal fill-in (random permutation)', xlab = 'no. of params', ylab = 'ratio')
abline(lm(df_random$no_params ~ df_random$results), col = 'black')
abline(lm(df_random$results ~ df_random$no_params), col = 'black')
plot(df_random$no_params, df_random$results, type = 'p',
main = 'ratio of fill-in to optimal fill-in (random permutation)', xlab = 'no. of params', ylab = 'ratio')
abline(lm(df_random$results ~ df_random$no_params), col = 'black')
plot(df_reverse$no_params, df_reverse$results, type = 'l',
main = 'ratio of fill-in to optimal fill-in (reverse permutation)', xlab = 'no. of params', ylab = 'ratio')
abline(lm(df_reverse$results ~ df_reverse$no_params), col = 'black')
plot(df_reverse$no_params, df_reverse$results, type = 'p',
main = 'ratio of fill-in to optimal fill-in (reverse permutation)', xlab = 'no. of params', ylab = 'ratio')
abline(lm(df_reverse$results ~ df_reverse$no_params), col = 'black')
plot(df_random$no_params, df_random$results, type = 'p',
main = 'ratio of fill-in to optimal fill-in (random permutation)', xlab = 'no. of params', ylab = 'ratio')
abline(lm(df_random$results ~ df_random$no_params), col = 'black')
plot(df_reverse$no_params, df_reverse$results, type = 'l',
main = 'ratio of fill-in to optimal fill-in', xlab = 'no. of params', ylab = 'ratio')
points(df_reverse$no_params, df_reverse$results, col = 'black', pch = "o")
plot(df_reverse$no_params, df_reverse$results, type = 'l',
main = 'ratio of fill-in to optimal fill-in', xlab = 'no. of params', ylab = 'ratio')
points(df_reverse$no_params, df_reverse$results, col = 'black', pch = "o")
points(df_random$no_params, df_random$results, col = 'red', pch = "*")
lines(df_random$no_params, df_random$results, col = 'red')
legend(0, 5000, legend=c("reverse","random"), col=c("black","red"), pch=c("o","*"))
plot(df_reverse$no_params, df_reverse$results, type = 'p',
main = 'ratio of fill-in to optimal fill-in', xlab = 'no. of params', ylab = 'ratio')
points(df_reverse$no_params, df_reverse$results, col = 'black', pch = "o")
points(df_random$no_params, df_random$results, col = 'red', pch = "*")
plot(df_reverse$no_params, df_reverse$results, type = 'p',
main = 'ratio of fill-in to optimal fill-in', xlab = 'no. of params', ylab = 'ratio')
points(df_random$no_params, df_random$results, col = 'red', pch = "*")
lines(df_random$no_params, df_random$results, col = 'red')
ablines(lm(df_random$results ~ df_random$no_params), col = 'red')
points(df_random$no_params, df_random$results, col = 'red', pch = "*")
plot(df_reverse$no_params, df_reverse$results, type = 'p',
main = 'ratio of fill-in to optimal fill-in', xlab = 'no. of params', ylab = 'ratio')
points(df_random$no_params, df_random$results, col = 'red', pch = "*")
abline(lm(df_reverse$results ~ df_reverse$no_params), col = 'black')
abline(lm(df_random$results ~ df_random$no_params), col = 'red')
legend(0, 5000, legend=c("reverse","random"), col=c("black","red"), pch=c("o","*"))
plot(df_reverse$no_params, df_reverse$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero (reverse permutation)',
xlab = 'no. of params', ylab = 'percentage filled')
abline(lm(df_reverse$percentage_fill ~ (df_reverse$no_params^2)), col="red")
plot(df_random$no_params, df_random$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero (random permutation)',
xlab = 'no. of params', ylab = 'percentage filled')
abline(lm(df_random$percentage_fill ~ (df_random$no_params^2)), col="red")
plot(df_reverse$no_params, df_reverse$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero (reverse permutation)',
xlab = 'no. of params', ylab = 'percentage filled')
abline(lm(df_reverse$percentage_fill ~ (df_reverse$no_params^2)), col="red")
plot(df_random$no_params, df_random$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero (random permutation)',
xlab = 'no. of params', ylab = 'percentage filled')
abline(lm(df_random$percentage_fill ~ (df_random$no_params^2)), col="red")
plot(df_reverse$no_params, df_reverse$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero of cholesky factor',
xlab = 'no. of params', ylab = 'percentage filled', ylim = c(0, 0.5))
abline(lm(df_reverse$percentage_fill ~ (df_reverse$no_params^2)), col="black")
points(df_random$no_params, df_random$percentage_fill, pch = '*', col = "red")
abline(lm(df_random$percentage_fill ~ (df_random$no_params^2)), col = "red")
legend(0, 0.3, legend=c("reverse","random"), col=c("black","red"), pch=c("o","*"))
# import libraries
library(Matrix)
library(spam)
library(spam64)
library(ggplot2)
# number of children at each level
level1 <- c(10, 50, 100)
l <- length(level1)
# store values of i and j, and the number of parameters
test2_cols <- rep(level1, l)
test2_rows <- c()
for (i in 1:l){
test2_rows <- c(test2_rows, rep(level1[i], l))
}
num_params <- rep(0, l^2)
for (i in 1:l){
for (j in 1:l){
num_params[(i-1)*l + j] <- level1[i]*level1[j] + level1[i] + 1
}
}
# with reverse labelling (this takes some time)
results_reverse <- rep(0, l^2)
for (i in 1:l){
for (j in 1:l){
temp <- centered_fillin2(method = "matrix", permute_method = "reverse",
i = level1[i], j = level1[j], permute = FALSE)
results_reverse[(i-1)*l + j] <- temp$diff
}
}
print(results_reverse) # not optimal! with reverse labelling the ratio is very bad.
# with random labelling
reps <- 30 # reduce this number since this might take a while
results <- rep(0, reps) # take the average to account for random effects
results_random <- rep(0, l^2)
for (i in 1:l){
for (j in 1:l){
print(paste0("level 1: ", level1[i], ", level 2: ", level1[j]))
for (k in 1:reps){
print(paste0("iteration", k))
temp <- centered_fillin2(method = "matrix", permute_method = "random",
i = level1[i], j = level1[j], permute = FALSE)
results[k] <- temp$diff
}
results_random[(i-1)*l + j] <- mean(results)
}
}
print(results_random) # not optimal! the random labelling it is not as bad, but the ratio is still not great.
# calculate percentage of matrix filled in
perc_fill_reverse <- rep(0, l^2)
perc_fill_random <- perc_fill_reverse
for (i in 1:length(num_params)){
perc_fill_reverse[i] <- results_reverse[i] * (num_params[i]-1)/num_params[i]^2
perc_fill_random[i] <- results_random[i] * (num_params[i]-1)/num_params[i]^2
}
# plot performance against number of parameters
df_reverse <- data.frame(i = test2_rows, j = test2_cols, results = results_reverse, no_params = num_params, percentage_fill = perc_fill_reverse)
df_random <- data.frame(i = test2_rows, j = test2_cols, results = results_random, no_params = num_params, percentage_fill = perc_fill_random)
plot(df_reverse$no_params, df_reverse$results, type = 'p',
main = 'ratio of fill-in to optimal fill-in (reverse permutation)', xlab = 'no. of params', ylab = 'ratio')
abline(lm(df_reverse$results ~ df_reverse$no_params), col = 'black')
plot(df_random$no_params, df_random$results, type = 'p',
main = 'ratio of fill-in to optimal fill-in (random permutation)', xlab = 'no. of params', ylab = 'ratio')
abline(lm(df_random$results ~ df_random$no_params), col = 'black')
plot(df_reverse$no_params, df_reverse$results, type = 'p',
main = 'ratio of fill-in to optimal fill-in', xlab = 'no. of params', ylab = 'ratio')
points(df_random$no_params, df_random$results, col = 'red', pch = "*")
abline(lm(df_reverse$results ~ df_reverse$no_params), col = 'black')
abline(lm(df_random$results ~ df_random$no_params), col = 'red')
legend(0, 5000, legend=c("reverse","random"), col=c("black","red"), pch=c("o","*"))
plot(df_reverse$no_params, df_reverse$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero (reverse permutation)',
xlab = 'no. of params', ylab = 'percentage filled')
abline(lm(df_reverse$percentage_fill ~ (df_reverse$no_params^2)), col="red")
plot(df_random$no_params, df_random$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero (random permutation)',
xlab = 'no. of params', ylab = 'percentage filled')
plot(df_reverse$no_params, df_reverse$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero (reverse permutation)',
xlab = 'no. of params', ylab = 'percentage filled')
abline(lm(df_reverse$percentage_fill ~ (df_reverse$no_params^2)), col="red")
plot(df_random$no_params, df_random$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero (random permutation)',
xlab = 'no. of params', ylab = 'percentage filled')
abline(lm(df_random$percentage_fill ~ (df_random$no_params^2)), col="red")
plot(df_reverse$no_params, df_reverse$percentage_fill, type = 'p', main = 'percentage of entries that are non-zero of cholesky factor',
xlab = 'no. of params', ylab = 'percentage filled', ylim = c(0, 0.5))
abline(lm(df_reverse$percentage_fill ~ (df_reverse$no_params^2)), col="black")
points(df_random$no_params, df_random$percentage_fill, pch = '*', col = "red")
abline(lm(df_random$percentage_fill ~ (df_random$no_params^2)), col = "red")
legend(0, 0.3, legend=c("reverse","random"), col=c("black","red"), pch=c("o","*"))
